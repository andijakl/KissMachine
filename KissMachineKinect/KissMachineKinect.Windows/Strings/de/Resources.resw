<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="About.Text" xml:space="preserve">
    <value>About</value>
  </data>
  <data name="AboutDevelopedBy.Text" xml:space="preserve">
    <value>Entwickelt von Andreas Jakl</value>
  </data>
  <data name="AboutGitHub.Content" xml:space="preserve">
    <value>Projektwebseite auf GitHub</value>
  </data>
  <data name="AboutGitHub.NavigateUri" xml:space="preserve">
    <value>https://github.com/andijakl/KissMachine</value>
  </data>
  <data name="AboutText.Text" xml:space="preserve">
    <value>Bussi Maschine</value>
  </data>
  <data name="AboutTwitter.Content" xml:space="preserve">
    <value>Auf Twitter folgen</value>
  </data>
  <data name="AboutTwitter.NavigateUri" xml:space="preserve">
    <value>https://www.twitter.com/andijakl</value>
  </data>
  <data name="AnotherPhoto_00" xml:space="preserve">
    <value>Ah, ihr wollt also noch ein Foto machen? Dann bleibt bitte noch kurz stehen...</value>
  </data>
  <data name="AnotherPhoto_01" xml:space="preserve">
    <value>Bereit für's nächste Foto? Wartet bitte kurz!</value>
  </data>
  <data name="AnotherPhoto_02" xml:space="preserve">
    <value>Ich finde, dass ihr das noch besser könnt. Versucht es nochmal!</value>
  </data>
  <data name="AnotherPhoto_03" xml:space="preserve">
    <value>Einmal geht's noch, einmal geht's noch leicht! Nächster Versuch!</value>
  </data>
  <data name="BusyInitializingKinect" xml:space="preserve">
    <value>Initialisiere Kinect Sensor ...</value>
  </data>
  <data name="BusyLoading" xml:space="preserve">
    <value>Lade ...</value>
  </data>
  <data name="Description.Text" xml:space="preserve">
    <value>Beschreibung</value>
  </data>
  <data name="DescriptionText.Text" xml:space="preserve">
    <value>Eine komplett automatisierte, Augmented Reality Photo-Booth!
Für den Einsatz bei Hochzeiten und Parties konzipiert.

Jede von der App erkannte Person wird mit einem Herz im Gesicht markiert. Kommen sich zwei Personen nahe genug, werden sie aufgefordert, sich ein Bussi zu geben. Es startet ein Countdown, danach wird ein Foto geschossen. Dieses wird im Bilder-Ordner gespeichert und zusätzlich für einige Sekunden angezeigt.

Die App funktioniert komplett berührungslos: die Personen werden von der Kinect erkannt, Fotos werden im richtigen Moment automatisch gemacht. Die Interaktion mit den Personen erfolgt über Sprachausgabe und angezeigtem Text.</value>
  </data>
  <data name="DownloadingPhoto" xml:space="preserve">
    <value>Bitte warten - Übertrage das Foto ...</value>
  </data>
  <data name="ErrorNoKinectAvailableText" xml:space="preserve">
    <value>Konnte keinen Kinect v2 Sensor finden. Stelle sicher, dass die Kinect an den PC angesteckt, mit Strom versorgt ist und dass die Treiber installiert sind (inkl. einem laufenden KinectMonitor-Service).</value>
  </data>
  <data name="ErrorNoKinectAvailableTitle" xml:space="preserve">
    <value>Kinect nicht gefunden</value>
  </data>
  <data name="ErrorSavingPhotoFromKinectText" xml:space="preserve">
    <value>Konnte das Foto nicht speichern. Bitte versucht es noch einmal, oder meldet das Problem sonst an den Verantwortlichen! </value>
  </data>
  <data name="ErrorSavingPhotoFromKinectTitle" xml:space="preserve">
    <value>Fehler beim Speichern des Fotos</value>
  </data>
  <data name="GiveAKiss_00" xml:space="preserve">
    <value>Gebt euch ein Bussi!</value>
  </data>
  <data name="GiveAKiss_01" xml:space="preserve">
    <value>Küsst euch!</value>
  </data>
  <data name="GiveAKiss_02" xml:space="preserve">
    <value>Knutschen!</value>
  </data>
  <data name="GiveAKiss_03" xml:space="preserve">
    <value>Gebt's euch a Bussal!</value>
  </data>
  <data name="GiveAKiss_04" xml:space="preserve">
    <value>Wie wär's mit einem Bussi?</value>
  </data>
  <data name="GiveAKiss_05" xml:space="preserve">
    <value>Ich will einen Schmatzer sehen!</value>
  </data>
  <data name="KissThankYou_00" xml:space="preserve">
    <value>Dankeschön! Ich hoffe, das Foto gefällt euch!</value>
  </data>
  <data name="KissThankYou_01" xml:space="preserve">
    <value>Ah - das ist wahre Liebe! Gefällt euch das Foto?</value>
  </data>
  <data name="KissThankYou_02" xml:space="preserve">
    <value>A schöns Bussal! Was sagt's zum Foto?</value>
  </data>
  <data name="KissThankYou_03" xml:space="preserve">
    <value>Wie war das Bussi? Das Foto ist auf jeden Fall super!</value>
  </data>
  <data name="KissThankYou_04" xml:space="preserve">
    <value>Ihr habt die Bussimaschine zum Glühen gebracht! Hier euer Foto!</value>
  </data>
  <data name="KissThankYou_05" xml:space="preserve">
    <value>Na, das geht besser. Findet ihr nicht? Hier das Foto!</value>
  </data>
  <data name="KissThankYou_06" xml:space="preserve">
    <value>Da muss mehr Leidenschaft rein - schaut selbst!</value>
  </data>
  <data name="Kiss_00" xml:space="preserve">
    <value>Bussi!</value>
  </data>
  <data name="Kiss_01" xml:space="preserve">
    <value>Kuss!</value>
  </data>
  <data name="Kiss_02" xml:space="preserve">
    <value>Schmatzer!</value>
  </data>
  <data name="Kiss_03" xml:space="preserve">
    <value>Bussal!</value>
  </data>
  <data name="MinDistanceText" xml:space="preserve">
    <value>Minimale Distanz [m]: {0:0.00}</value>
  </data>
  <data name="Privacy.Text" xml:space="preserve">
    <value>Privatsphäre</value>
  </data>
  <data name="PrivacyText.Text" xml:space="preserve">
    <value>Von der App werden keine spezifischen Nutzungsdaten erfasst und übertragen. Die aufgenommenen Fotos werden lediglich lokal auf Ihrem PC in der Foto-Bibliothek gespeichert. Bitte stellen Sie bei Veranstaltungen sicher, dass Sie die Erlaubnis Ihrer Gäste für die Aufnahme von Fotos haben. Der komplette Quellcode der App ist auf GitHub unter der Open Source GPL v3-Lizenz verfügbar.</value>
  </data>
  <data name="RemovedMinPairPlayerHint" xml:space="preserve">
    <value>Ich kann euch nicht mehr sehen! Falls ihr euch zu stürmisch umarmt, kann ich euch nicht mehr so gut erkennen.</value>
  </data>
  <data name="ResourceLanguage" xml:space="preserve">
    <value>de</value>
  </data>
  <data name="Settings.Text" xml:space="preserve">
    <value>Einstellungen</value>
  </data>
  <data name="SettingsLowPerformance.Text" xml:space="preserve">
    <value>Low Performance Modus</value>
  </data>
  <data name="SettingsLowPerformanceText.Text" xml:space="preserve">
    <value>Bei schwachen PCs aktivieren. Hier werden weniger Bilder pro Sekunde angezeigt. Das verbessert die Verarbeitung, resultiert aber in einer langsameren Anzeige.</value>
  </data>
  <data name="SettingsSony.Text" xml:space="preserve">
    <value>Sony Kamera verwenden</value>
  </data>
  <data name="SettingsSonyText.Text" xml:space="preserve">
    <value>Foto mit einer per WiFi Direkt verbundenen Sony-Kamera statt der Kinect machen. Die Kamera wird dabei komplett von der App ferngesteuert. Getestet mit der Sony DSC-RX100M3.
Achtung: nach dem Ändern dieser Einstellung die App neu starten! Die Kinect wird auf jeden Fall für den Live Stream und das Erkennen der Nutzer benötigt.

Anweisungen:
1. Auf der Kamera den Remote Control-Modus starten. z.B. über "Smart Remote Control", "Turn Wi-Fi on" oder "Control with Smartphone"
2. Den PC mit dem Wi-Fi der Kamera verbinden
3. "Bussi Maschine" starten</value>
  </data>
  <data name="SupportedCameras.Content" xml:space="preserve">
    <value>Unterstützte Kameramodelle</value>
  </data>
  <data name="SupportedCameras.NavigateUri" xml:space="preserve">
    <value>https://developer.sony.com/develop/cameras/device-support/</value>
  </data>
</root>